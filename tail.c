/* *  Frantisek Sedlacek *  VUT FIT Brno *  Priklad: IJC-DU2 *  19.04. 2023 */#include <stdio.h>#include <stdlib.h>#include <string.h>#define CBLEN 4095// by my understanding of assignment This Circular buffer// will be used for loading a line and then printing it outstruct Circular_buffer{    char* buf;    long start;    long end;    long limit;    long lines;    char overflow;};/* cb_create * Creates buffer of size n */struct Circular_buffer *cb_create(long n){    struct Circular_buffer *buffer;    buffer=malloc(sizeof(struct Circular_buffer));    buffer->buf = malloc(sizeof(char)*n);    if(buffer->buf == NULL){        fprintf(stderr,"Failed to allocate buffer space");        exit(1);    }    for(long i = 0 ; i < n; i++){        buffer->buf[i]=1;    }    buffer->start=0;    buffer->end=0;    buffer->limit=n;    buffer->lines=0;    buffer->overflow=0;    return buffer;}/* * cp_put * puts a line into the buffer * throws overflow error when line exceeds * buffer size limit, but keeps shortened line */void cb_put(struct Circular_buffer *cb, const char *line){    for(long i = 0; line[i]!='\0'&& line[i]!='\n';i++){        if(cb->buf[cb->end]=='\0'&&cb->lines!=0)cb->lines--;        cb->buf[cb->end++]=line[i];        cb->end%=cb->limit;        if(cb->end==cb->start){            cb->start++;            cb->start%=cb->limit;        }    }    if(cb->buf[cb->end]=='\0'&&cb->lines!=0)cb->lines--;    cb->buf[cb->end++]='\0';    cb->end%=cb->limit;    if(cb->end==cb->start){        cb->start++;        cb->start%=cb->limit;    }    cb->lines++;}long findEndpoint(struct Circular_buffer *cb){    long i;    for(i = cb->start; cb->buf[i%cb->limit]!='\0';i++); // COUNTER    i++;    return i%cb->limit;}char* cb_get(struct Circular_buffer *cb){    if(cb->lines==0)return NULL;    long endpoint= findEndpoint(cb);    if(cb->start>=endpoint){ // rotation to the right        while(cb->start!=cb->limit){            char temp=cb->buf[cb->limit-1];            for(long i = cb->limit-1;i > 0; i--){                cb->buf[i]=cb->buf[i-1];            }            cb->buf[0]=temp;            cb->start++;            cb->end++;            endpoint++;        }        cb->start=0;    }    char* oldstart=&cb->buf[cb->start];    cb->start=endpoint;    cb->lines--;    return oldstart;}/* * cb_free * Frees the buffers memory. */void cb_free(struct Circular_buffer *cb){    free(cb->buf);    free(cb);}int main(int argc, char **argv) {    long line_count=10;    char input=0;    char *param_ptr;    if(argc>1) {// looking for options        param_ptr=argv[1];        if(!strcmp(param_ptr,"-n")){            if(argc == 2){                fprintf(stderr,"Option requires number\n");                exit(1);            }            line_count=atol(argv[2]);            if(line_count<=0){                fprintf(stderr,"Invalid option parameter\n");                exit(1);            }            if(argc==4){                param_ptr=argv[3];            }else{                input=1;            }        }    }else{        input=1;    }    FILE *fp;    if(!input){        fp=fopen(param_ptr,"r");        if(fp==NULL){            fprintf(stderr,"File could not be opened.\n");            exit(1);        }    }    char* temp_buff=malloc(sizeof(char)*CBLEN);    struct Circular_buffer* cb_buffer=cb_create(CBLEN);    while((fgets(temp_buff,CBLEN,(input)?stdin:fp))!=NULL){        cb_put(cb_buffer,temp_buff);    }    while(cb_buffer->lines>line_count){        cb_get(cb_buffer);    }    while(cb_buffer->lines>0){        printf("%s",cb_get(cb_buffer));        if(cb_buffer->lines!=0){            printf("\n");        }    }    cb_free(cb_buffer);    free(temp_buff);return 0;}